## Chapter1

### Javadoc

文档注释 
/**

*author 龚豪

*version 1.0

/



### 路径

相对路径：从当前目录到对应文件夹的路径

绝对路径：从顶级目录到对应文件夹的路径



JDK、JRE、JVM的关系

JDK = JRE + java开发工具

JRE = JVM + 核心类库



### 环境变量作用及其配置方法

环境变量的作用指的是在任意dos目录，可以是使用java和javac命令

配置方法是在JAVA_HOME中填写指向JDK的主路径



### JAVA编写步骤

1、编写java代码

2、javac编译，得到对应的.class字节码文件

3、java运行，本质就是.class文件加载到 JVM中运行。



### JAVA代码规范

1、类、方法的注释是Javadoc即文档注释

2、非javadoc注释是给代码维护的人看的注释，有单行注释和多行注释

3、代码可以统一按tab键位移

4、代码不要超过八十个字符

5、等号之间要用空格

6、有行尾风格（推荐）和次行风格









## Chapter2

数据类型分为两种 数值型和引用类型

数值型：byte（1）、short（2）、int（4）、long（8）、

​				float（4）、double（8）、char（2）、boolean（1）、

引用类型：类、接口、数组



char是字符 用的是’‘ 单引号 双引号是字符串 要分清楚 不然会报错

char本质是一个整数 可以运算

char类型的 数值型是输出 对应的Unicode字符 



布尔类型只有true和false

一般用于逻辑运算 if判断 if else while for

不能用0或其他数字替代 





#### AutoConvert 自动转换类型

操作数小的类型自动转换为操作数大的类型

char>int>long>float>double

byte>short>int>long>float>double



细节一:有多种类型的时候,要把数值类型转换为操作数最大的类型进行计算

细节二:不能将数值类型操作数大的转换为操作数小的

细节三:char类型 和 byte/short类型不能相互转换



细节四:byte short char 在进行计算的时候会自动转换为int类型

细节五:Boolean类型不能进行运算

细节六:在进行运算的时候会转换为操作数最大的





##### 强制类型转换

就是将容量大的数据类型转换为容量小的数据类型,要运用强制转换符进行转换,但这样会造成精度损失,数值不准确.

细节一:将容量大的数据类型转换为容量小的数据类型要用强制转换符

细节二:强制转换符只针对最近的数,要用小括号提升优先级

细节三:char类型可以保存常量,但不能保存变量.要用强制转换

细节四:byte short char类型计算时,会自动转换为int类型.





##### 基本数据类型和String字符串数据类型

将String字符串数据类型用方法进行转换的时候要注意格式

列如 "123" 可以转换为 int

列如 "hello"不可以转换为int





## Chapter3



### 算数运算符

正号 负号 加减乘除 取余 

自增(前):先运算后取值 a=2 b=++a    a=3 b=3

自增(后):先取值后运算 a=2 b=a++    a=3 b=2

字符串相加 "Cha" + "pter"       "Chapter"





### 关系运算符

== != <= >= > <





### 逻辑运算符

a&b 逻辑与 a和b同时为true 则结果为true 否则为false

a&&b 短路与 a和b同时为true 则结果为true 否则为false

区别: 短路与 第一个条件结果为false 第二个条件将不会执行 效率高

​		 逻辑与 第一个条件结果为false 第二个条件仍然会执行  效率低

a|b 逻辑或 a和b中有一个为true 则结果为true 否则为false

a||b  短路与 a和b中有一个为true 则结果为true 否则为false

区别: 短路或 第一个条件结果为true 第二个条件将不会执行 效率高

​		  逻辑或 无论第一个条件结果是不是true 都会执行第二个条件 效率低

a! 异或 a为true 则结果为false a为false 结果为true

a^b 逻辑异或 当a和b的结果不同时则为true 相同是则为false





### 赋值运算符

将某个运算后的值赋值给变量

= += -= *= /= %=

a += b 就等于 a = a+b 其他都是一样的



byte b = 3

b += 2  实际上有类型转换 (byte)(b= b +2)





### 三元运算符

小窍门:一真大师  为真(true)则返回第一个表达式 为假(false)则返回第二个表达式

a = 10;

b = 99;

int result = a<b ? a++ : b--;

system.out.println("result" + result); 结果为10

system.out.println(a); 结果为 11

system.out.println(b); 结果为 99

表达式1 和 表达式2 要为可以赋给接受变量的类型 或是自动转换 或是强制转换

三元运算符本质就是if else 语句



### 位运算符

按位与:两位同为1则为1,否则为0

按位或:两位中有一个为1则为1,否则为0

按位异或:两位中一个为0一个为1,则为1否则为0

按位反:0->1 , 1->0

int a = 1 >> 2  本质就是 1/2/2 = 0

int b = 1 <<2   本质就是 1 * 2 * 2 = 4



### 运算符的优先级

![image-20220815114753135](C:\Users\14916\AppData\Roaming\Typora\typora-user-images\image-20220815114753135.png)



优先级排序

1.() {}等

2.单目运算符

3.算数运算符

4.位移运算符

5.比较运算符

6.逻辑运算符

7.三元运算符

8.赋值运算符





### 标识符命名规则

1.由26个英文字母和0-9的数字,有_和$组成

2.数字不能开头

3.不能用关键词和保留字,但可以包含关键字和保留字

4.区分大小写

5.标识符里不能用空格





标识符命名规范(更加专业)

包名:多字母组成,全部用小写字母,xxx_yyy_zzz

类名,接口名:首字母大写,TankShotGame(大驼峰)

方法名,变量名:首字母小写,tankShotGame(小驼峰)

常量名:多字母组成,全部用大写字母,XXX_YYY_ZZZ





### 原码,反码,补码

![image-20220815211929987](C:\Users\14916\AppData\Roaming\Typora\typora-user-images\image-20220815211929987.png)







## Chapter4



### switch语句细节

1.表达式数据类型,和case中常量的类型是一致的,或者可以相互转换的类型,输入的是字符,常量的类型是int

2.switch表达式的返回值类型是(byte,short,char,int,enum枚举,string)

3.case语句中所包含的值 是常量 不能是变量

4.default是可选的,当没有合适的case,执行default

5.break是用来执行完一个case分支后跳出switch语句,如果没有break,顺序执行swicth语句.





### for循环细节

1.循环语句表达式返回的值是布尔类型

2.for循环中的初始化和变量迭代可以写在其他地方,但两边分号不能省略

3.for循环中的初始化可以有多个,但要求类型一致,并且中间用逗号隔开,变量迭代也可以有多个,中间用逗号隔开



### 编程思想

化繁为简:把复杂的需求化解为简单的需求,逐步实现

先死后活:先考虑固定的值,再考虑变化的值





### 三种跳转区别

break:结束这层循环,执行外层循环

continue:结束本次循环,执行下一次循环

return:在方法中,结束方法,在main方法中,退出程序









## Chapter5

### 数组



基本数据类型赋值是"值引用",二者不相关联

int n1 =10;

int n2 = n1;

n2 = 20;

System.out.println(n2);

结果为 20

数组赋值是"地址引用",引用的是地址 有关联

int c1 = {10,20,30};

int c2 = c1;

c2[0] = 40;

System.out.println(c2);

结果为{40,20,30}









## Chapter6

### 类与方法

#### 成员方法

public 返回数据类型 方法名(形参列表){ //方法体

​		语句;

​		return;

}



1.形参列表:表示方法传入的值cal(int n1) getSum(int num1,int num2)

2.放回数据类型:表示成员方法输出,void表示无返回值

3.方法体语句:表示一个具体的方法

4.return不是必须的





##### 使用注意事项和细节

访问修饰符(控制范围)

有四种访问修饰符public/protected/默认/private

返回数据类型

1.一个方法只有一个返回值(可以把值放入数组)

2.返回数据类型可以为任意数据类型,基本数据类型和引用数据类型

3.如果方法要求有返回类型,方法体的最后一句必须是return 值,

​	而且要求返回类型与return 的值一致或兼容

4.void表示无返回值,或者return;

5.public void f3(int num1,int num2)  形式参数

​	a.f3(10,20)  实际参数

6.实际参数的顺序必须与形式参数顺序一致

​	public void f3(String str,int num2)

​	a.f3("对的",10)√

​	a.f3(10,"错的")x

7.方法里不能嵌套方法



方法调用的细节

1.同一类方法直接调用即可 

2.不同类方法需先创建对象才可调用





方法传参中的细节

方法传递的值 是值赋予 

基本数据类型的是传递 不是引用 不可以可以通过形参去影响到实参

引用数据类型传递的是地址 可以通过形参去影响到实参





方法中可变参数的细节

1.可变参数的实参为0个或任意个数

2.可变参数和普通参数一起,要把可变参数放到最后

3.可变参数可以为数组

4.可变参数本质为数组

5.一个形参列表只能有一个可变参数.





### 作用域

1.主要分为属性(成员变量)和局部变量

2.成员变量之外的变量都是局部变量

3.成员变量不用赋值也可以使用(因为有默认值),局部变量必须赋值之后才能使用.





细节:

1.成员变量和局部变量可以重名,采取就近原则

2.一个方法中,不能有重复属性名

3.属性生命周期比较长,随着对象的创建而创建,随着对象的销毁而销毁

局部变量生命周期比较短,随着代码块的创建而创建,随着代码块的结束而结束.





### 构造器

细节

1.一个类中可以有多个不同参数的构造器,即构造器的重铸

2.构造器名要和类名一致

3.构造器没有返回值

4.构造器是完成对象的初始化,不是创建对象

5.创建对象时,系统自动调用该类的构造

6.没有创建构造器的时候,系统会自动创建一个无参构造器

7.创建了构造器之后,会把默认的无参构造器覆盖,要想使用无参构造器,除非显示的定义一下



 Setter and Getter

使私人属性可以供其他类使用





流程分析

1.加载Person类信息,只会加载一次

2.在堆中分配空间

3.对象初始化,3.1 默认初始化 3.2 显式初始化 3.3 构造器初始化

4.在对象中返回堆的地址,即对象的引用





This 细节

1.this用来访问本类的属性,方法,构造器

2.this用来区分当前量的属性和局部变量

3.访问成员方法的语法(this.方法(参数列表))

4.访问构造器方法this(参数列表)(即在构造器中访问另一个构造器,必须放在第一排)

5.this不能再类定义的方法外部使用,只能在类定义方法内部使用.





### 继承

1.子类继承可以访问非私有的属性和方法,不能够直接访问父类的私有方法和属性,但私有的属性和方法可以通过父类的公有方法来调用访问.

2.子类必须调用父类的构造器,完成父类的初始化

3.当创建子类对象时,默认会调用父类的无参构造器,如果父类的无参构造器被覆盖,那在子类中必须用super()方法来指定调用那个构造器来完成父类的初始化,否则编译不通过.

4.如果想调用那个父类构造器,用super显示的定义一下

5.super语句必须放在子类构造器的第一行

6.super和this只能使用一个.

7.java所有类是Object的子类,Object是所有类的父类

8.父类构造器并不只限于直接父类,将追溯到Object

9,java中的基础是单继承,A只能继承B,B继承C

10.继承要符合逻辑关系,要符合is-a的关系







#### super

细节

1.调用父类构造器的好处(分工明确,父类的属性父类初始化,子类的属性子类初始化)

2.当子类和父类有属性和方法重名时,用super直接调用父类的属性和方法,没有重名时,直接使用方法或者this或者super是一样的效果.

3.super能直接访问不限于父类属性,如果父类和爷爷类有同名的成员,也可以使用super去调用爷爷类的成员,当然要遵守就近原则,也要遵守访问权限规则.





#### this与super的区别

访问属性:this是先访问本类的属性,如果没有再寻找父类的属性,继续往上查找

​				super是先访问父类的属性,如果没有再往上查找

访问方法:this是先访问本类的方法,如果没有再寻找父类的方法,继续往上查找

​				super是先访问父类的方法,如果没有再往上查找

调用构造器:this调用本类的构造器,放在构造器的首行

​					super调用父类的构造器,放在子类构造器的首行

特殊:this表示当前对象,super表示子类访问父类





#### 方法的重写(override)

1.子类的参数列表和方法名要和父类的参数列表和方法名一致

2.子类的返回类型要和父类的返回类型一致,或者是父类返回类型的子类 例如:Object的子类 String

3.子类的访问权限和父类的访问权限一致,或者小于父类的访问权限 public > protected > 默认 > private





#### 重写(override)和重载(overload)的区别

重写的发生范围在子类中,重载的发生范围在本类中

重写的方法名和参数列表要和父类一致,重载的方法名要和重写的方法一致,但参数列表的个数,顺序,类型要不同

重写的子类返回类型要与父类的返回类型一致,或者是父类访问类型的子类,重载则无要求

重写的子类访问权限要与父类的访问权限一致,或者是小于父类访问权限,重载则无要求





### 多态

多态的具体表现

查找属性看编译类型 查找方法看运行类型.

1.一个对象的编译类型和运行类型可以是不一样的

2.编译类型在创建对象的时候就确定了 不能改变

3.运行类型是可以改变的

4.编译类型看等号的左边,运行类型看等号的右边.





#### 向上转型

1.可以调用父类的所有成员方法

2.不可以调用子类的特有方法

3.在编译阶段,能运行哪些成员方法,是有编译类型决定的.

4.在最终运行阶段,还是看运行类型的具体实现,即调用方法时,按照从子类(运行类型)开始查找





#### 向下转型

1.子类类型 引用名  =  (子类类型)  父类引用

2.要求强制转型的父类对象必须指向引用对象

3.只能强转父类的引用,不能强转父类的对象.

4.向下转型后,可以调用子类的所有对象





#### java的动态绑定机制

1.当调用成员方法时,该方法会和对象的内存地址/运行类型的对象进行绑定

2.当调用成员变量时,没有动态绑定机制,哪里访问,哪里调用.







#### Obejct类



##### equals

==与equals的区别

== 可以判断基本数值类型是否相等

== 还可以判断引用类型是否相等 比较的是地址是否一样

equals只能判断引用类型

String.equals重写了equals方法 比较所有数值是否相等

Object.equals没有重写equals方法,还是比较对象地址.



##### hashcode

1.提高具有哈希结构的容器的效率

2.两个引用,如果对象的地址一样,那么哈希值也一样

3.两个引用,如果对象的地址不一样,那么哈希值也不一样

4.哈希值是参照对象的地址来的,但不能把哈希值当做地址(不完全是)







## Chapter7

静态static    类属性/静态属性

static是所有对象共享的变量

static存储在哪个位置要看版本,jdk8之前放在方法区中,jdk8之后存放在堆中.



1.什么时候需要类变量

当需要所有对象都共享同一个变量的时候,需要类变量

2.类变量是每个对象变量都可以享用,普通变量是成员对象实例的一个变量

3.有类名.类属性方法使用(推荐) 还有 实例对象名.类属性使用方法

4.加上static就是类属性

5.实例对象不能通过类名.类属性来访问

6.类属性随着类创建时就初始化了,所以可以通过类名.类属性直接访问

7.类随着类的创建而创建,随着类的销毁而销毁

类方法只能访问类属性和类方法,普通方法既可以访问普通属性和普通方法还可以访问类属性和类方法

类方法不能使用this和super等关键字

重要:必须遵循访问权限

 



### 代码块细节

静态代码块只加载一次,普通代码块创建一次对象就加载一次

1.对象实例化的时候 静态代码块会被加载

2.子类继承父类 实例子类对象也会加载父类的静态代码块

3.调用类里的静态成员也会加载静态代码块.普通代码块则不会调用.



4.优先级

类中同时有静态属性和静态方法 优先级是一样的,谁在前面谁先调用 (静态比普通重要 先调用)

类中同时有普通属性和普通方法 优先级是一样的,谁在前面谁先调用

构造方法最后调用.



执行顺序

1.父类静态成员和静态代码块优先级一样,看先后顺序

2.子类静态成员和静态代码块优先级一样,看先后顺序

3.父类的普通代码块和普通成员优先级一样,看先后顺序

4.父类的构造器

5.子类的普通代码块和普通成员优先级一样,看先后顺序

6.子类的构造器

7.静态代码块只能调用静态成员(属性和方法),普通代码块可以调用所有成员.



